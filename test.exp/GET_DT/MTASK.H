/*
*******************************************************************************
　マルチタスク　サポート　ライブラリ
		'ABK project' all right reserved. Copyright (C)nabe@abk
*******************************************************************************
　　1997/12/29　〜

とりあえず、ドキュメントの代わり


　アセンブラソースには、うっとおしい程コメントが書いてありますが、
　ディスクリプタテーブルを操作している部分は、
　ＣＰＵのディスクリプタの仕様の説明がある参考文献（ドキュメント参照）を
　見ながらでないと分からないでしょう･･･(^^;;)


===============================================================================
■共通の注意点
===============================================================================

	・存在しないセレクタ値や無効なセレクタ値を指定すると、プログラムが保護
	　例外で停止したり、無効な結果が現れたりします。

	・あらゆる引数は、範囲外、規定外の値を指定した場合、どうなるか分かりま
	　せん。必ず範囲内の値を指定してください。



///////////////////////////////////////////////////////////////////////////////
●新規セグメント作成
///////////////////////////////////////////////////////////////////////////////

int make_selector(int page);

	page　＝割り当てるページ(4Kbyte単位)数

	戻り値
	　0〜0fff8h ＝正常終了（LDTの新セグメントセレクタ）
	　0ffffh〜  ＝異常終了（メモリ/セレクタ不足）
	　　　　　　　戻り値の上位16bit には最大ページ数が入ってる


///////////////////////////////////////////////////////////////////////////////
●指定セグメントの開放
///////////////////////////////////////////////////////////////////////////////

int make_selector(int selector);

	selector　＝開放するセレクタ

	戻り値
	　　　　０ ＝正常終了
	　それ以外 ＝異常終了（９ならば無効なセレクタ）



///////////////////////////////////////////////////////////////////////////////
●ＧＤＴ／ＬＤＴのディスクリプタ情報取得
///////////////////////////////////////////////////////////////////////////////

int get_dt(int selector,struct descriptor *descriptor);

	selector　　＝開放するセレクタ
	*descriptor ＝結果を返す構造体

	戻り値
	　０＝正常終了：ﾒﾓﾘ 形式
	　１＝　 〃 　：ｼｽﾃﾑ形式
	　２＝　 〃 　：ｹﾞｰﾄ形式
	　４＝使用不可能なセレクタ

　　セグメントディスクリプタタイプは、sd_type[type] をに入っています。
　　なお、システム型とメモリ型を区別する為に、システム型の場合 +16 されていま
　すが、本来のセグメントタイプは 4 bit で表現されています(0〜15)。


*/
// メモリ/システム･セグメント形式
struct	mem_descriptor
{
	long	base;		// ﾘﾆｱ空間ﾍﾞｰｽｵﾌｾｯﾄ
	long	limit;		// ﾘﾐｯﾄ値(byte)
	char	level;		// ｾｸﾞﾒﾝﾄ使用可能ﾚﾍﾞﾙ
	char	type;		// ｾｸﾞﾒﾝﾄﾀｲﾌﾟ
	char	use;		// use ﾃﾞｨﾌｫﾙﾄ
};

struct	sys_descriptor
{
	long	base;		// ﾘﾆｱ空間ﾍﾞｰｽｵﾌｾｯﾄ
	long	limit;		// ﾘﾐｯﾄ値(byte)
	char	level;		// ｾｸﾞﾒﾝﾄ使用可能ﾚﾍﾞﾙ
	char	type;		// ｾｸﾞﾒﾝﾄﾀｲﾌﾟ
};

// ゲート･セグメント形式
struct	gate_descriptor
{
	long	offset;		// ｵﾌｾｯﾄ
	long	selector;	// ｾﾚｸﾀ(ｹﾞｰﾄﾃﾞｰﾀのある)
	char	level;		// ｾｸﾞﾒﾝﾄ使用可能ﾚﾍﾞﾙ
	char	type;		// ｾｸﾞﾒﾝﾄﾀｲﾌﾟ
	char	dword_count;	// 呼び出し時ｽﾀｯｸｺﾋﾟｰ回数
};

typedef	union
{
	struct	mem_descriptor		mem;	// メモリ･セグメント形式
	struct	sys_descriptor		sys;	// システム･セグメント形式
	struct	gate_descriptor		gate;	// ゲート･セグメント形式
} descriptor;

/*



///////////////////////////////////////////////////////////////////////////////
●セレクタ値のリミット値を取得する
///////////////////////////////////////////////////////////////////////////////

int get_limit(int selector);

	selector ＝ディスクリプタ･セレクタ

	戻り値   ＝リミット値



///////////////////////////////////////////////////////////////////////////////
●セレクタ値のリニア空間オフセットを取得する
///////////////////////////////////////////////////////////////////////////////

int get_linear_offset(int selector);

	selector ＝ディスクリプタ･セレクタ

	戻り値   ＝リニア空間オフセット



///////////////////////////////////////////////////////////////////////////////
●リニア空間オフセットを物理アドレスに変換する
///////////////////////////////////////////////////////////////////////////////

int linear_to_physical(int linear_offset);

	linear_offset ＝リニア空間オフセット

	戻り値　　    ＝物理アドレス

	この関数はDos-Extenderファンクション(2509h)を利用しています。

	そのアドレスがメモリ上に存在しない場合、戻り値は不定です。
	仮想記憶使用中は、使用しないでください。
	（対応してる、Dos-Extenderが存在するかどうかは知りませんが……）。


　　＊テクリカルインフォメーョン＊

	物理アドレスとは言っても、ＸＭＳ Ver3 以降を組み込んでＤＯＳ自体が
	仮想８６モードで動いている場合は、下位１ＭＢはその時のメモリマッピ
	ング＝物理アドレスと扱われます。


///////////////////////////////////////////////////////////////////////////////
●セレクタ値とセレクタ内オフセットから物理アドレスを取得する
///////////////////////////////////////////////////////////////////////////////

int get_physical_address(int offset,int selector);

	selector ＝ディスクリプタ･セレクタ
	offset   ＝セレクタ内オフセット

	戻り値   ＝物理アドレス


///////////////////////////////////////////////////////////////////////////////
●新規にＬＤＴを作成し、そこに現ＬＤＴの内容を複写する
///////////////////////////////////////////////////////////////////////////////

void	make_new_ldt(int selctor,void *offset,int size);

	selctor ＝ セレクタ　　←新規にＬＤＴを作成する
	*offset  ＝ オフセット　←　メモリのセクレタ：オフセット
	size    ＝ 大きさ(byte) 下位16ビットのみ使用 1〜0ffffh 0=64KB

　　与えられたメモリアドレスから４ＫＢを、ＬＤＴとして使用します。
　　それまで使用してきたＬＤＴセレクタ値（x4h,xCh）はそのまま利用できます。

　　このコールは、ＬＤＴの大きさが足りなくて新規にＬＤＴを作れない、
　　または、通常のＬＤＴはプログラムが勝手にいじらない方がいい為、
　　特別にプログラム使用するＬＤＴを確保する為に使用しています。



///////////////////////////////////////////////////////////////////////////////
●３８６メモリ形式のセグメント･ディスクリプタを作成します
///////////////////////////////////////////////////////////////////////////////

void make_mems(int selctor,struct mem_descriptor *memd);

	selctor	＝ セレクタ値（作成するセレクタ値）

struct	mem_descriptor
{
	int	base;	// リニア空間ベースオフセット
	int	size;	// サイズ（単位 byte）：必ず 0 以外の数を指定する事
	char	level;	// 特権レベル(0〜3)
	char	type;	// メモリセグメントタイプ（get_gdtのﾀｲﾌﾟ定義参照）
};		   	//  必ず 00h〜0fh(0〜15) の間の値であること。

	※get_dt(ﾃﾞｨｽｸﾘﾌﾟﾀ情報取得) に使うものと同じ形式です



///////////////////////////////////////////////////////////////////////////////
●ＴＳＳ[Task State Segment]−ディスクリプタをＧＤＴに作成
///////////////////////////////////////////////////////////////////////////////

void make_tss(int selector,struct tss_descriptor *tssd);

	selector ＝ＴＳＳディスクリプタを作成するセレクタ値
	*tssd　　＝ＴＳＳディスクリプタの内容を示す構造体

	※規定外の値を指定しても、動作しますが、使用時大変危険です

	セレクタ値にＬＤＴを指定しても、ＬＤＴにセレクタを作成しますが、
	ＴＲにロードする時に、保護エラーが発生します。
	（つまり使えない）

*/
// TSS セグメント･ディスクリプタ形式構造体
struct	tss_descriptor
{
	int	base;		// ﾘﾆｱ空間ﾍﾞｰｽｵﾌｾｯﾄ
	int	limit;		// ﾘﾐｯﾄ(byte 単位)
	char	level;		// 特権ﾚﾍﾞﾙ
};
/*

	・ベースオフセットは、線型アドレス空間のオフセットで指定してください。
	・セレクタ値は、0fff8h までの８の倍数です｡
	・リミット値の最大は、0ffffffh までです。
	・特権レベルは、0〜3 の間です。

	注意：規定外の値を指定ししても問題なくプロセスは終了しますが、
	　　　そのディスクリプの内容は保障できません。
	　　　また、絶対に無闇なセレクタ値を指定しないでください。

///////////////////////////////////////////////////////////////////////////////
●ゲートディスクリプタをＧＤＴに作成
///////////////////////////////////////////////////////////////////////////////

void make_gate(int selector,struct gate_descriptor *gated);

	selector ＝ゲートディスクリプタを作成するセレクタ
	*gated   ＝ゲートの形式を示す構造体

struct	gate_descriptor
{
	long	offset;		// ｵﾌｾｯﾄ
	long	selector;	// ｾﾚｸﾀ(ｹﾞｰﾄﾃﾞｰﾀのある)
	char	level;		// ｾｸﾞﾒﾝﾄ使用可能ﾚﾍﾞﾙ
	char	type;		// ｾｸﾞﾒﾝﾄﾀｲﾌﾟ(0〜15)
	char	dword_count;	// 呼び出し時ｽﾀｯｸｺﾋﾟｰ回数
};
	※この構造体はディスクリプタ情報取得に使用する物と同一です。

	・ベースオフセットは、セレクタ内オフセットで指定してください。
	・セレクタ値は、0fff8h までの８の倍数です｡
	・特権レベルは、0〜3 の間です。
	・タイプは、0〜15のうち、ゲート型（4〜7､C､E､F）のいずれかを
	　指定してください。それ以外の値は絶対にやめてくたざい。
	・スタックコピー回数(dword count)の最大値は 1fh(31)です。


	注意：規定外の値を指定ししても問題なくプロセスは終了しますが、
	　　　そのディスクリプの内容は保障できません。
	　　　また、絶対に無闇なセレクタ値を指定しないでください。



///////////////////////////////////////////////////////////////////////////////
●レジスタのロード・ストア
///////////////////////////////////////////////////////////////////////////////

void	store_tr(int TSS);
int	load_tr();

	ＴＲレジスタへストアしたり、
	ＴＲレジスタをロードしたりします。

int	load_cs();
int	load_ds();

	cs または ds レジスタの内容をロードします。






===============================================================================
■マルチタスク支援ルーチン
===============================================================================


	！注意：このルーチン使用の前にＬＤＴの拡張が必要です。


	以下は実際にマルチタスクプログラムつまりタスクカーネルを作成する場合に
	それを支援する為のルーチン群です。

	以下カーネルとはマルチタスクを管理するＯＳのような役割をするもの、
	シェルとはマルチタスクサービスを受けながら、
	実行されるものを意味します。

	特に断りのないかぎり、これらルーチンはカーネル内部以外では
	使用しないでください。

	※適当にしか書いてないので「Kernel.txt」を参照してね。
	　ちなみに、こっちにしか書いてない関数もある。


///////////////////////////////////////////////////////////////////////////////
●自分のプログラムに割り当てられたメモリ変更
///////////////////////////////////////////////////////////////////////////////

int mem_size_change(const char *programfile,int page,void *work);

	*programfile	= 自分自身のプログラムファイルネーム
	page		= 余分に割り当てるメモリサイズ(page)
	*work		= 作業領域メモリ(200byte 以上)

	正常終了 = 0


	EXP プログラムは起動時に、すべてのメモリを割り当てられます。
	しかしこのままでは、新たにメモリを確保することが出来ません。
	そこで自分自身のメモリサイズを変更します。

	page には、最低限必要なメモリサイズよりどれだけ余分にメモリを
	割り当てるかページ(4KB)単位で指定します。

	load_shell 等を実行する前に必ず実行しなければなりません。


///////////////////////////////////////////////////////////////////////////////
●シェルプログラムのロード
///////////////////////////////////////////////////////////////////////////////

int shell_load(const char *filename,void *work);

	filename ＝ ファイル名

	*work ＝ 作業領域メモリ(200byte 以上)

	指定のファイルハンドラ番号でオープンされているファイルを
	シェルプログラムとしてロードします。
	そして初期化処理をしてから、カーネルに戻ってきます。


	！注意：カーネルコールの登録よりも先に実行する事。


	戻り値 ＝ シェル番号
	    -1 ＝ エラー



///////////////////////////////////////////////////////////////////////////////
●マルチタスク関連（タスクスイッチング）の初期化を行う
///////////////////////////////////////////////////////////////////////////////

int mtask_init(int machin,int *taskinfo);

	machin ＝ 使用機種を指定します。
		　以下の定数を利用してください。
*/

#define	PC98	0	// NEC PC9801 ｼﾘｰｽﾞ / EPSON互換機
#define	FMT	1	// Fujitsu FM-TOWNS ｼﾘｰｽﾞ
#define	FM	2	// Fujitsu FMR/FM-TOWNS ｼﾘｰｽﾞ / Panacom ｼﾘｰｽﾞ
#define	PCAT	3	// IBM PC/AT互換機(通称 DOS/V機)

/*
	*taskinfo ＝ タスクインフォメイションアドレス
		　　 カーネルのタスクインフォメイションとして登録される。

	！注意：この初期化を実行したら、
		終了時には必ず「mtask_end()」を実行する事。
		Ctrl-C等すべてを含む。例外割り込みも今のところどうしょもない。



///////////////////////////////////////////////////////////////////////////////
●シェルをタスクとして実行開始（シェルをアクティブタスクとして登録する）
///////////////////////////////////////////////////////////////////////////////

int shell_register(int shell_number,void *taskinfo);

	shell_number ＝ シェル番号
	*taskinfo    ＝ タスクインフォメイションへのポインタ

	シェルをアクティブタスクとして登録する
	（ログイン後のオープニング表示から、シェル実行が始まる）

	タスクインフォメイションに割り当てられたタスク番号が書き込まれる。



///////////////////////////////////////////////////////////////////////////////
●意図的なタスクスイッチング
///////////////////////////////////////////////////////////////////////////////

int task_swich();

	意図的にタスクをスイッチする。
	復帰のときはこの命令の次から復帰する。

	※カーネルでのみ使用可能


///////////////////////////////////////////////////////////////////////////////
●割り込みカウンタのアドレスの取得
///////////////////////////////////////////////////////////////////////////////

int *counter_address_get();

	割り込みカウンターアドレスを取得する。
	このカウンタは割り込みが起こる毎にインクリメントされる。
	割り込みは、「mtask_init()」を実行した時から始まる。

	このカウンタはユーザーが自由に使用できる。
	無論書き換えても構わない。
	また、いつでも実行可能。



///////////////////////////////////////////////////////////////////////////////
●指定のタスクを終了させる
///////////////////////////////////////////////////////////////////////////////

int task_end(int task_number);

	task_number ＝ タスク番号

	指定タスク番号のタスクを終了させる。
	カーネル内で、回線切断を見分けて終了させたり、
	強制的に終了させたり、シェルの要求により終了させたりする。



///////////////////////////////////////////////////////////////////////////////
●マルチタスクの終了
///////////////////////////////////////////////////////////////////////////////

int mtask_end();

	マルチタスク処理を終了する。
	終了前に、必ず実行する必要がある。



///////////////////////////////////////////////////////////////////////////////
●システム（カーネル）コールの登録
///////////////////////////////////////////////////////////////////////////////

int	kernel_call_register(int pointer[],int manys);

	pointer[0 - manys]　＝　関数へのポインタ
	manys               ＝　呼び出されるシステムコールの最大数

	ポインタの０番は予約済です。登録時に自動的に書き換えられます。
	しかし、シェルロードをすべて終了すれば、
	後で０番を書き換えてしまっても構いません。


///////////////////////////////////////////////////////////////////////////////
●システム（カーネル）コール
///////////////////////////////////////////////////////////////////////////////

　※シェル専用関数

int　　kernel_call(number, ...);

	カーネルをコールする。
	ナンバーによって、コール内容を決定する。

	pointer[X] : X=number


///////////////////////////////////////////////////////////////////////////////
●初期化処理終了後のカーネルへの復帰
///////////////////////////////////////////////////////////////////////////////

　※シェル専用関数

void kernel_return();

	初期化処理終了後、処理をカーネルへ戻す。
	タスクとして実行する場合は、この関数の復帰する形で実行します。




###############################################################################
############################################################# end of readme ###
###############################################################################
*/


char	*sd_type[]={
	"リードのみ",
	"リードのみ・アクセスあり",
	"リード/ライト",
	"リード/ライト・アクセスあり",
	"リードのみ・下方伸長",
	"リードのみ・下方伸長・アクセスあり",
	"リード/ライト・下方伸長",
	"リード/ライト・下方伸長・アクセスあり",

	"実行のみ",
	"実行のみ・アクセスあり",
	"実行/リード",
	"実行/リード・アクセスあり",
	"実行のみ・適応型",
	"実行のみ・適応型・アクセスあり",
	"実行/リード・適応型",
	"実行/リード・適応型・アクセスあり",

// ここから、システム、ゲートディスクリプタ
	"未定義",
	"286TSS､利用可",
	"ＬＤＴ",
	"286TSS､BUSY",
	"286ｺｰﾙ･ゲート",
	"タスク･ゲート",
	"286割り込みゲート",
	"286トラップゲート",

	"未定義",
	"386TSS､利用可",
	"未定義",
	"386TSS､BUSY",
	"386ｺｰﾙ･ゲート",
	"未定義",
	"386割り込みゲート",
	"386トラップゲート"
};

char	*sd_type_s[]={
	"R","R","R/W","R/W","R/D","R/D","R/W/D","R/W/D",
	"X","X","R/X","R/X","R/A","R/A","R/X/A","R/X/A",
	// system
	"---","286TSS","LDT","286TSS","286-g","task-g","286INT","286TRP",
	"---","386TSS","---","386TSS","386-g","---","386INT","386TRP"
};


extern	int	make_segment(int page);
extern	int	free_segment(int selector);

extern	int	get_dt(int selector,descriptor *descriptor);
extern	int	get_limit(int selector);
extern	int	get_linear_offset(int selector);
extern	int	get_physical_address(int offset,int selector);
extern	int	linear_to_physical(int linear_offset);

extern	void	make_mems(int selector,struct mem_descriptor *memd);
extern	void	make_tss (int selector,struct tss_descriptor *tssd);
extern	void	make_gate(int selector,struct gate_descriptor *gated);
extern	void	make_new_ldt(int selctor,void *offset,int size);


extern	void	store_tr(int TSS);
extern	int	load_tr();
extern	int	load_cs(int TSS);
extern	int	load_ds();
extern	int	load_far_mem(int sel, void *ptr);



////////// マルチタスク支援ルーチン //////////


extern	int mem_size_change(const char *programfile,int page,void *work);
extern	int shell_load(const char *filename,void *work);
extern	int mtask_init(int machin,int *taskinfo);

extern	int shell_register(int shell_number,void *taskinfo);
extern	int tasl_end(int task_number);
extern	int task_swich();
extern	int *counter_address_get();


extern	int mtask_end();

extern	int kernel_call_register(int pointer[],int manys);
extern	int kernel_call(int number, ...);

extern	void kernel_return();
