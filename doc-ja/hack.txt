;******************************************************************************
;* Free386 Hacker document                                                    *
;******************************************************************************
[TAB=8]

最終修正  2001/03/06

;##############################################################################
;## Source files
;##############################################################################

	FREE386.ASM	Free386 Main ルーチン (主に16bit code)
	F386PROT.ASM	Free386 Protect Mode ルーチン
	F386DATA.ASM	Free386 データ領域
	TOWNS.ASM	FM TOWNS 固有の処理
	PC98.ASM	PC-98x1 固有の処理
	AT.ASM		PC/AT互換機 固有の処理
	-------------------------------------------------------------
	INT.ASM		Free386 Interrupt処理 (CPU,DOS-Extender Int等)
	INT_DOS.ASM	Free386 Interrupt処理 (DOS interrupt)
	INT_F386.ASM	Free386 独自ファンクション
	INT_DATA.ASM	Free386 割り込み関連データ。割り込みテーブルなど
	-------------------------------------------------------------
	START.ASM	スタートルーチン。動作定義内部変数の記述
	F386SEG.ASM	Free386 セグメント操作 (ORG:MT_SEG.ASM)
	F386SUB.ASM	Free386 固有のサブルーチン
	F386CV86.ASM	Protectモード←→V86モード、低レベル仲介ルーチン
	SUB.ASM		サブルーチン集 (16bit/32bit)
	-------------------------------------------------------------
	F386DEF.INC	Free386 全般の定義
	MACRO.ASM	マクロ定義
	NASM_ABK.H	NASM利用のための設定

　一番上のくくりは、%include で結合しています。これのファイル全部で１つのオ
ブジェクトファイルを作成します。

　二番目のくくりも、%include で結合しています。int.asm をアセンブルすること
で一つのオブジェクトファイルを生成します。

　三番目のくくりは、１つのファイルが１つのオブジェクトファイルに対応します。
モジュール（サブルーチン）の固まりだと思ってください。


　一番下の欄は、単体では意味をなしません。ほぼすべてのASMファイルで include
され利用されています。

;##############################################################################
;## Execute flow
;##############################################################################

　ファイル名から推測の付くとおり FREE386.ASM がメインです。

　歴史的な（？）流れとしては、このファイルにどんどん記述していて巨大化して
邪魔になった部位を他のファイルへ（%include）追い出し、最終的に別の obj に追
い出して……を繰り返して今のような形になりました。

　サブルーチンなどの説明で特に断りがない場合は、レジスタを保存してないとお
考えください。記述ミスもありますので、悩む時はルーチンソースを参照ください。

▼メイン処理

・start		jmp start
　　↓
・Free386	V86モードでの設定。VCPIの初期化、Free386本体をプロテクト
　　│		モードで実行する準備、XMS の確保、内部メモリの確保
　　│
　　│Protect モードへの切り換え / goto start32
　　↓
・F386prot	プロテクトモードでの処理。確保したメモリの張りつけ (paging)
　　│		ユーザ環境の構築（LDT内セレクタ作成など）
　　│		各機種固有処理ルーチンの呼び出し
　　│.exp ファイルのロードと実行
　　↓
  target.exp の実行

・int_dos	int 21h / ah=4ch ：プログラムの終了
　　↓
・Free386	END_program (32bit)
　　│		各機種固有の終了処理
　　│
　　│CPUモード切り換え
　　│
　　↓		*END_program16	エラーレベルの設定。XMSメモリの開放
・DOS				プログラムの終了（int 21h / ah=4ch）


▼割り込み処理

　割り込みテーブル自体はメイン処理において作成されるが、実際の割り込み処理は
メインルーチンとは完全に独立している。基本的に、Free386 の最低限のプロテクト
モード環境が揃っていれば、それだけで割り込み処理部は機能を果たす。

【DOS int】
・int_dos.asm (int 2xh のjmpラベル)
　　│
　　│＊int 21h の場合＊
　　│
　　│int 21h テーブルjmp
　　↓
　if (DOS-Extender function?) goto int.asm

【ハードウェアINT】
・int.asm
　　│
　　│DOS ルーチンへの chain
　　↓

【CPU例外】
・int.asm
　　│レジスタの表示（call register_dump [in f386sub]）
　　↓終了ラベルへの jmp / goto *END_program
・Free386.asm

【Free386拡張function】
・int_f386.asm
　　│
　　│各ファンクションへ
　　↓


【その他のINT】
・int.asm
　　│
　　│DOS ルーチンへの chain
　　↓


　F386int は int処理全般と、DOS-Extender で拡張されたファンクションの処理ル
ーチンが記述されている。
　F386intd には、仲介が必要な DOS function（バッファを介するものなど）が記述
されている。

　int処理ルーチン内部では、低レベルモード切り換えルーチンが呼ばれている。
　モード切り換えルーチンは、F386cv86 でありモードの切り換えの他、一般的なバ
ッファ仲介形ファンクションの処理ルーチンが記述してある。
　ネスト式のモード切り換えの中核はこの部分に記述してある。

;##############################################################################
;## Execute flow 2
;##############################################################################

基本は変わりませんが、既に少し古いです(^^;;

wriiten by nabe@abk (in '01/02/01)
-------------------------------------------------------------------------------
★main ルーチン★

100	goto *start

	;Free386.asm
1000	*start
1010	if (com 形式?) else end
1020	if (VCPIがある?) else end
1030	page table の初期設定と VCPI情報の設定
1040	最大物理メモリの取得とセーブ
1050	モード以降前の内部変数設定
1060	GDT / IDT のリニアアドレス算出
1065	CPUモード切り替え用構造体への保存
1070	call *setup_GDT
1080	CPUモード切り替え / goto *start32

1200	*setup_GDT
1210	GDTに必要なセレクタを設定 (F386_cs,F386_ds,LDT,TSS など多数)
1220	return

	;F386prot.asm
3000	*start32
3010	全メモリアクセスセレクタの作成
3020	VCPI からのメモリ取得と、ページテーブルの構成
3030	新たに獲得したメモリを利用して、LDTにユーザプログラム用 CS/DS の作成
3040	PSP セレクタの作成
3045	DOS環境変数セレクタの作成
3050	引数を解析
3060	実行ファイル名の検索 (ENV:PATH386)
3070	ファイルを開いて exp をロード / goto *.EXP (実行ファイル)

-------------------------------------------------------------------------------
★終了ルーチン★

	;in Free386.asm (16bit code)
1300	*END_program16
1310	エラーならばエラー表示
1320	エラーコードを返して終了 / return *DOS

	;(32bit code)
1400	*END_program
1410	セグメントレジスタ、スタックを設定
1420	VCPI から取得したメモリの開放
1430	CPUモード切り替え(to 16bit) / goto *END_program16

-------------------------------------------------------------------------------
★エラー終了ルーチン★

	;in Free386.asm (16bit code)
2600	*hook_int23h		;CTRL-C 処理ルーチン
2610	CPUモード切り替え(to 32bit) / goto *END_program

	;F386int.asm (32bit code)
4100	*Intel_int		;CPU例外割り込み (保護エラーなど)
4110	エラー時のレジスタセーブ
4120	call *register_dump	;ダンプ表示 (in F386sub.asm)
4130	goto *END_program

-------------------------------------------------------------------------------
★V86←→Protect Mode連携処理★

	:in Free386.asm (32bit code)
2000	*call_V86_int21		;DOS function 呼び出し
2010	レジスタのセーブ
2020	CPUモード切り替え(to 16bit) / goto *cv86i_in86

2100	*cv86i_in86	;(16bit code)
2110	目的ルーチンの呼び出し(int)
2120	CPUモード切り替え(to 32bit) / goto *cv86i_retPM

2200	*cv86i_retPM	;(32bit code)
2210	レジスタ復元
2220	Carry フラグのセーブ
2230	iretd

※他、類似ルーチンが多数（パラメタとなるレジスタで使い分け）。

-------------------------------------------------------------------------------
★割り込み処理★

	;in F386int.asm (32bit code)
4000	*PM_int_dummy
4010	goto *call_V86_int

4300	*intr		;ハードウェア割り込みの処理
4310	呼び出しint番号設定
4310	goto *call_V86_int


4500	*int_21h_XXh
	;DOS-Extender で拡張されてる int 21h function の処理

4600	*DOS_Extender_fn
	;DOS-Extender 拡張ファンクション (AH=25h,35H) / 未記述

	;in F386intd.asm (32bit code)
5000	*PM_int20h	;int 21h / 4ch へ chain や
5010	*PM_int22h-2fh	; DOS の呼び出し、何も処理しないなど。

5200	*PM_int21h
5210	割り込みテーブル (int21h_table) を参照し、テーブルジャンプ
	/ goto *int_21h_XXh

5300	*int_21h_XXh
	;単純に DOS を呼び出すことはできない function の処理（一部のみ）

;##############################################################################
;## F386DEF.inc
;##############################################################################

　Free386 全般の定義ファイルです。
　大体は読めばわかると思いますが、いくつか説明しておきます。

-------------------------------------------------------------------------------
DEBUG_1		equ	0	;Free386 内部メモリ情報 (64KB内)
DEBUG_2		equ	0	;int hook / needs REG_DEBUG=1
REG_DEBUG	equ	0	;レジスタダンプ表示ルーチンの搭載
-------------------------------------------------------------------------------

　ディバグの設定をします。
　DEBUG_1 は Free386本体の 64KBメモリ における空きメモリ状況を表示します。こ
れを参考にしながら、DOS仲介バッファのサイズを決定しています。

　DOSコールバッファサイズや、モード切り換え時の一時スタックサイズや、入れ子
割り込みの対応階層数を設定するときは、この値を参考にしながら「上位メモリから
のメモリアロケーションと下位メモリからのメモリアロケーションが重ならないよう」
注意してください（ハングアップや暴走の原因になります）。

　DEBUG_2 は int 21h function のログ（発効時、発効後のレジスタ内容）を標準出
力に吐きだすものです。REG_DEBUG を同時に 1 にしないとアセンブル時にエラーに
なります。

　REG_DEBUG を 1 にすると、レジスタダンプのディバグルーチンが組み込まれます。
こうすることで、（再入問題を別にすると）すべての箇所で

	call	debug_reg_dump

　というルーチンコールが使用できるようになります。
　このルーチンはすべてのレジスタの内容と

	Ddata0, Ddata1

　という2つの dword 変数を出力の内容します。
　この変数にはレジスタ以外に表示したい情報を設定してください。特になければ、
何も設定しなければいいだけですが、そのときは何らかの値が出力されます。

-------------------------------------------------------------------------------
for_TOWNS	equ	1	;TOWNS 用のバイナリ生成
for_PC98	equ	0	;PC-98x1 用のバイナリ生成
for_AT		equ	0	;PC/AT互換機 用のバイナリ生成
-------------------------------------------------------------------------------

　ターゲットマシンを選択します。
　この選択により、各機種固有のルーチン（towns.asm / pc98.asm / at.asm）が呼び
だされます。また同じ定義ファイル内で各種定数の設定されます。

　すべてを 0 にすると、各機種汎用の binary が生成されます。この binary は DOS
-Extender 汎用プログラム（もちろん割り込みを使用しないもの）を、あらゆる DOS
/ VCPI / XMS 環境で使用するための DOS-Extender になります。

　各機種用の binary を生成するとき、誤って make している機種とは違う機種用の
binary を実行してしまわないように注意してください。f386.mak は free386 を標準
の DOS-Extender として利用してますので、注意が必要です。
（ちなみに、よく間違えて実行してハングアップさせてます(^^;;）

-------------------------------------------------------------------------------
_TITLE_disp	equ	1	;タイトル表示
_Verbose	equ	0	;冗長な表示
_see_PATH386	equ	1	;環境変数 PATH386 を参照する
_see_PATH	equ	0	;環境変数 PATH を参照する
_reset_CRTC	equ	3	;終了時 CRTC/VRAM の初期化設定 (TOWNSのみ有効)
_check_MACHINE	equ	1	;簡易機種判別を行う
-------------------------------------------------------------------------------

　内部動作変数の初期値です。内部変数を再アセンブルで変更する場合はこの値を
設定してください。
　変数の詳細はユーザリファレンスの内部変数の項を参照ください。

-------------------------------------------------------------------------------
SAVE_8259A	equ	1	;ハードウェア割り込みマスクを終了時に復元する
Rec_Real_Vec	equ	1	;リアルモード割り込みベクタの復元
-------------------------------------------------------------------------------

　8259A の割り込みマスク状況を見て、割り込みマスク及び、リアルモード割り込み
ベクタの復元を設定します。

　通常はこのままで問題ないハズですが、.exp 動作中にリアルモードベクタ、割り
込みマスクなどを設定する DOS アプリや、常駐アプリにそのようなシグナルを与え
る .exp が存在するとき問題が発生します。
（そのようなアプリがあるかは不明ですが……）

-------------------------------------------------------------------------------
F386ERR		equ	0fch	;Free386内部エラー終了時のエラーコード
CPU_Fault	equ	0fdh	;CPU fault
-------------------------------------------------------------------------------

　Free386 がエラーで強制終了したときのエラーコードです。
　.exp アプリと被るなど問題がある場合は適時書き換えてください。

-------------------------------------------------------------------------------
V86_stack_size	equ	200h	;=byte / V86 モードスタックサイズ 
PM_stack_size	equ	400h	;=byte / プロテクトモードスタックサイズ
VCPI_stack_size	equ	 40h	;VCPI call(to V86) 時のみ使用するスタックサイズ
-------------------------------------------------------------------------------

　Free386 が使用するスタックサイズを設定しています。
　それぞれ、100h回push できる値として設定しています。

　VCPI_stack_size は、CPUモードを切り換えるときにのみ使用するスタックです。
　通常は変更する必要はないと思われます（大きい分には構いませんが、下手に小さ
くすると暴走の原因です）。

-------------------------------------------------------------------------------
ISTK_v86_size	equ	200h	;モード切り換え時、V86 側スタック保証サイズ
ISTK_prot_size	equ	400h	;モード切り換え時、Protect 側スタック保証サイズ
INT_nests	equ	4	;割り込みネスト数 (※Prot / V86 それぞれにつき)
-------------------------------------------------------------------------------

　CPU モードを V86←→Protect モードと切り換えるとき、切り換えた先で使用でき
るスタックサイズを指定しています。これもそれぞれ 100h 回 push できる値にして
あります。

　DOS-Extender の仕様（マニュアルに記載）では、100 byte のスタックが保証され
ていますが、ここで指定されている 100h dword それよりも随分大きい値です。
　なお、この設定値は Free386 自体が呼び出しに使用するスタックを含んでいます
ので、実際に使用できるスタックはこれより多少小さくなります。

　INT_nests は、ネスト式のモード切り換えの対応ネスト数を設定します。
　この値は、Protect→v86、v86→Protect、それぞれの切り換えについての許容回数
です。
　このことから、CPUモード切り換え用に確保されるスタックのサイズは以下のよう
に精算されます。

-------------------------------------------------------------------------------
_POOL_mem_pages	equ	8	;ページングのために予約するメモリページ数
-------------------------------------------------------------------------------

　物理メモリのマッピングなどのサービス提供時、必要となるページテーブル用のメ
モリを予約するページ数です。
　ここで予約したページは、ターゲットexp ロードに使用できるメモリとしてカウン
トされなくなります（メモリが極端に不足してる場合はプールしなくなります）。

　１ページは 4KB です。１ページで、すべてのアドレスを先頭から 4MBのブロック
に分割したときの１ブロックのメモリの張りつけが可能になります。
　また、標準API のロード用メモリとして、このプールメモリが使用されることも
あります。

-------------------------------------------------------------------------------
work_size	equ	200h	;汎用ワークサイズ / min 200h
INT_BUF_size	equ	4000h	;V86 ←→ Protect 間データ渡し配列サイズ
-------------------------------------------------------------------------------

　汎用ワークは、Free386 が内部的に使用しているワークです。
　最小が 200h byte になっているのは、ロードファイルのヘッダ情報ロードにこの
ワーク領域を使っているためで、一般的な P3 ヘッダは 200h byte にヘッダ情報が
収まっています。

　INT_BUF_size は、DOS function で ProtectモードとV86モードでデータをやり取り
する際に使用するデータバッファのサイズ(byte) です。
　大きくすればするほど V86←→Protect の切り換え回数が減り処理が高速になりま
すが、あまり大きくしすぎると Free386 の 64KB 本体メモリに収まらなくなる可能性
があります（警告などはでず、そのまま誤動作するはずです）。 >>DEBUG_1 参照

　一番恩恵を受けるのは、ファイルの読み出しと書き込みだと思いますが、4000h 程
大きくしなくても 1000h ぐらいにしておけば大して変わらないような気もします。

　また、int 21h / ah=09h などバッファのデータを一気に書き出すファンクション
では、ここで指定したサイズ以降は無視されます。仕様です。通常は問題にならない
と思いますが……

-------------------------------------------------------------------------------
USER_Start_adr	equ	400000h	;ユーザ用リニアアドレスの開始番地
Unit_of_MEM	equ	400000h	;メモリアドレスの割り当て単位(/byte)
MIN_heap_mem	equ	200000h	;最小ヒープリニアアドレス
-------------------------------------------------------------------------------

　プロテクト管理メモリに関する設定値です。
　詳細は Hack document(hack.txt) の「●メモリ管理方法」の項を参照してください。

-------------------------------------------------------------------------------
int_21h_MAXF	equ	80h	;int 21h のファンクション番号の最大値 +1
DOS_Ext_MAXF	equ	18h	;DOS-Extender拡張ファンクションの最大func番号+1
-------------------------------------------------------------------------------

　DOS-Extender function / DOS function の最大ファンクション番号を規定していま
す。前者は自由に書き換えられますが、後者は単純に書き換えても誤動作するだけで
す（データ領域の書き換えが必要）。

　DOS_Ext_MAXF の値をいかに設定しても、function C0h〜C3h は別に扱われます。
　int_21h_MAXF の値を 100h にすると、テーブルjmp の前の最大値チェックがなくな
って微々たる高速化が実現しますが、80h*4 = 512 byte のメモリを無駄にしますので
通常はこのままでいいように思います。

-------------------------------------------------------------------------------
USER_ds		equ	14h	;ユーザープログラム用 DSセレクタ（変更不可）
-------------------------------------------------------------------------------

　従来はユーザプログラムの ds を設定していましたが、現在はこの値を変更しても
ロード ds を変更することはできません。LDT内の空きセレクタを順番に割り当てて
いるためです。

　この定数は現在、CTRL-C や致命的エラーのフックで ds を設定するためにのみ使
用されています。


○機種情報の定義
-------------------------------------------------------------------------------
MACHINE_CODE	equ	20h	;TOWNSシリーズ
-------------------------------------------------------------------------------

　機種コードを定義しています。
　これは、Free386拡張ファンクションの ah=01h で返される値を規定するものです。

-------------------------------------------------------------------------------
%define	MACHINE_STRING	'FM TOWNS'
-------------------------------------------------------------------------------

　マシンを示す文字列を指定するものです。
　これは、メッセージの機種部分に使われいます。

-------------------------------------------------------------------------------
%define	Free386_API	'f386_fmt.api'	;機種固有APIのファイル名
-------------------------------------------------------------------------------

　各機種用の標準API のファイル名です。

;##############################################################################
;## Free386.asm	本体内サービスルーチン
;##############################################################################
・top_malloc
・top_calloc
・down_malloc
・down_calloc
　	引数	ax = size (byte)
  	Ret	di = offset
		di 以外のレジスタは保存される

　Free386.com が専有する 64KB のメモリの中のヒープメモリを管理する。
　top_malloc は、アドレスの小さい方から順にメモリを割りつける。down_malloc
はアドレスの大きい方から小さい方に向かってメモリを割りつける。後者はこれは
スタックの確保用で、返されるポインタは確保した領域の"一番上位のアドレス"+1
を示している（つまり、そのまま sp などに代入できる値）。
　calloc は、確保したメモリを 0 初期化する。

　奇数や区切りの悪い数でメモリ確保を行うと、以後のメモリ確保が align され
なくなるので、注意すべきである。
　また、top_malloc と down_malloc で割り当てた領域が重なったかどうかをチェ
ックしないのでこの点も注意すべきである。

	[top_mem_offset] < [down_mem_offset]	となっていれば問題ない。

・free_EMB
　XMS によって確保した EMB (Extended Memory Block)、つまりプロテクトメモリ
を開放する。XMS によって確保成功後はかならず call free_EMB を実行してから
プログラムを終了すべきである。
　ディバガなどでトレースしてるときに、ついうっかり "q" などと打って強制終
了させると、XMS メモリが開放されす、空になるので再起動させるハメになる……。


;##############################################################################
;## F386cv86.asm	V86モードcall呼び出しルーチン
;##############################################################################
・setup_cv86
　ルーチンの初期設定。"*top_malloc" "*down_malloc" を用いてモード切り換え
に必要なメモリを確保している。

・clear_mode_data
　モード切り換えのネスト式スタックを初期化するルーチン。呼び出し時に
DS=F386_DS であること。

・call_V86_int
　引数	SS:ESP	+00h INT番号*4
		+04h ret offset
		+08h ret selector
		+0ch eflags
　全レジスタを保存して目的の int を呼び出す。セグメントセレクタの受渡しは
できない。結果はキャリーフラグのみセーブされる。

・call_V86_int21
　"push 21h*4" を実行後、call_V86_int の処理に移る。

・call_V86_int21_2
・call_V86_int21_3
　それぞれ、00h、'$' で終わる DS:EDX で指定される string をバッファにコピー
してから、DOS を呼び出す。その他の機能は call_V86_int21 と同じ。

・call_V86
　引数　SS:ESP	+00h	return offset (戻りラベル)
		+04h	V86側 call adress / cs:ip
		+08h	V86 ds
		+0ch	V86 es
		+10h	V86 fs
		+14h	V86 gs
　唯一 call 文で呼び出せる V86ルーチン呼び出し。int で呼ぶもの、far で呼ぶも
の、単純に call するもののいずれの目的にも使用できる。
　実行後のセグメントレジスタ値はスタックの同じ場所に記録される。フラグも呼び
出し後のものが記録されている（IOPLなど特殊な値は除く）。

・int_V86
　V86モードで int 発生時にプロテクトモードに切り換える処理を行うルーチン。
　DOS-Extender 拡張 function の"常にプロテクトモードで発生する割り込み(2506h)"
を処理する目的で利用される。
　これを処理するために、メモリ中には予め
	call int_buf
	nop
という命令が256個並べられている（動的にプログラムを生成している >setup_V86）。
この命令列の先頭と、スタックに積まれた retラベル の差を見ることで目的の INT
番号を算出している。

;##############################################################################
;## F386data.asm
;##############################################################################

　データ領域です。
　重要変数だけではなく、予め初期値として必要な値が代入されています。

;##############################################################################
;## int.asm
;##############################################################################

　int_dos.asm / int_f386.asm / int_data.asm と共に CPU 割り込み、ハードウェア
割り込みをはじめ DOS function の仲介処理、DOS-Extender 拡張ファンクション、
Free386 拡張ファンクションのルーチンが記載されています。

　ソースをみていると
	check_int_from_V86		;from V86?
　というマクロをたまにみかけますが、自力で V86 モードに切り換えたいたときの名
残で、現在は役をなしてないません（macro.asm で定義されていますが、今は何も展
開されないダミーマクロとなってます）。

・PM_int_xxh
　見てのとおり CPU 例外については、一応 intel の予約である 00h〜1fh まです
べてを並べてあります。
　call 文を並べているのは、call 実行時に call 命令の次の番地をreturnラベル
としてスタックにプッシュすることを利用して INT番号を算出するための仕組みです。
　INT番号をメモリに代入して jmp などいろいろ考えた末、call が一番省エネのよ
うでしたのでこのようにしてあります。

　ここに記述してある CPU 例外のうち スタック例外 は意味をなしていません。
　スタックが無効なので、CPU 例外に飛ぼうとしても例外を起こした番地をスタック
に積むことが出来ず、そのまま CPU が停止している模様です。

・intr_Mx
・intr_Sx
　それぞれ割り込みコントローラのマスタ側、スレーブ側の割り込み処理ルーチンで
す。ハードウェア割り込みのINT番号が 16個 記述すればわざわざ別々に用意しなく
てもいいのですが、PC/AT互換機ではそうもいかないようでして……。

　また、CPU例外とINT番号が被っている場合は、割り込みサービスレジスタを参照す
るという面倒な処理が入っています。割り込みベクタの設定ルーチンにも同様に無駄
な処理が入っているので、書いてはみたものの、近々再配置する予定です。

・int_21h_xxh
　DOS function のうち、DOS-Extender においては処理内容の異なるものを記述して
あります。バッファを介するコールは、基本的に手で専用ルーチンを書いてあげる必
要があります。

・DOS_Extender_fn
　DOS-Extender拡張ファンクションです。
　DOS function のうち ah=25h または ah=35 が DOS-Extender拡張call として定義
されています。al に機能番号が入っていて、このレジスタを参照してテーブルjmp
を行っています。

・DOS_Ext_fn_xxh
　DOS-Extender 拡張ファンクションを記述してあります。
　Ver1.2相当の拡張ファンクションはほぼ対応しています。詳細は Free386 プログ
ラマーズリファレンスを参照ください。

;##############################################################################
;## int_dos.asm
;##############################################################################

・PM_int_2xh
　DOS function を記述してあります。基本的には何もせず ret していますが、多少
意味のあるものについては dos に chain しています。

・PM_int_21h
　int 21h を発効したときに呼ばれるラベル。
　テーブルを参照し、ah と合致する function を呼び出しています。

・int_21h_xxh
　DOS funciton の大半はそのまま DOS のルーチンを呼び出していますが、中には
バッファを仲介したり、戻り値が string であったりと単純には処理できないもの
があり、それらを個別に記述してあります。

;##############################################################################
;## int_f386.asm
;##############################################################################

　Free386拡張ファンクションが記述されています。
　まだ内容は少ないですが。

・setup_F386_int
　Free386拡張ファンクションをセットアップしています。DOS-Extender拡張コール
を用いて割り込みベクタの設定をするという至極単樹なものです。f386prot.asm から
呼ばれています。

・Free386_function
　Free386拡張ファンクションである int 9ch に設定されるルーチンです。
　スタックを用いた単純なテーブルジャンプを行っています。

・F386fn_xxh
　実際のファンクションです。
　こういうのを書きたい人は申し出てください。多分、面白いと思います（私は好き
です）。

;##############################################################################
;## int_data.asm
;##############################################################################

　主にファンクションのジャンプテーブルが列挙してあります。
　その他、一般変数が多少定義されています。

・int21h_table
　int21h のファンクションテーブルです。
　もしファンクションの処理を変更したい場合はこの部分をいじるといいでしょう。

　FCB などの使用されてない部分に function を追加しても構いません。

・DOSExt_fn_table
　同じく、DOS-Extender 拡張ファンクションのjmpテーブルです。

・F386fn_table
　Free386 独自拡張のファンクションのjmpテーブルです。

;##############################################################################
;## F386seg.asm
;##############################################################################

　セレクタをページングテーブルを扱うサブルーチンです。
　サブルーチン化してあるので、i386 の特殊レジスタに慣れてなくてもこれを利用
すればメモリマッピングなどができるのでは……と思いますが。

・make_mems
・make_mems_4k
　引数	eax = 作成するセレクタ
	ds:edi	+00h d	ベースオフセット
		+04h d	リミット値 (サイズ-1)
		+08h b	特権レベル   (0〜 3 )
		+09h b	メモリタイプ (0〜0fh)

　元々 High-C 用に書いたライブラリを引っ張ってきたので、データの受渡しに構造
体を使用します。特権レベルとメモリタイプに範囲外の値を指定すると、正しくセレ
クタが作成されません。

　リミット値は _4K が付くものと付かないもので解釈が違います。

	make_mems	limit = size -1
	make_mems_4k	limit = size / 4K -1

　具体例として、limit値に 17h を指定したときのアドレス範囲を示します。

	make_mems	00000h  〜 00017h 	    18h byte
	make_mems_4k	00000h	〜 17fffh	 18000h byte

　メモリタイプは、セグメントディスクリプタの type フィールドに代入されますが、
CPUのマニュアルを見ないとよく分からないと思いますので、いくつか例を書いてお
きます。

	02h, 03h		Read / Write 可能
	0ah, 0bh		Read / eXecute(実行) 可能

　メモリタイプの bit 4 を 1 にすると、USE16 タイプのセレクタを作成します。
　なおメモリ形式のセレクタの場合、bit 0 は「CPU がそのセレクタにアクセスした
かどうか」を示しています。
　VRAM や CRTC の自動初期化判別は、このビットを参照して行っています。

・set_physical_mem
　引数	esi = 張りつけ先リニアアドレス
	edx = 張りつける物理アドレス
	ecx = 張りつけるページ数
　Ret	Cy  = 0 成功
	Cy  = 1 ページテーブル用のメモリが不足
　備考	全レジスタ保存

　物理メモリを指定のリニアアドレスに張りつけます。
　既に指定のリニアアドレスにメモリが張りつけられていても構わずメモリを張りつ
けます（古いほうのリニアアドレスは利用できてくなります）
　しかし、ページテーブル（用のメモリ）を多重に割りつけることはありません。

・alloc_ram
　引数	ecx = 張りつけるページ数
	esi = 物理メモリ張りつけ時にずらすアドレス(4KB単位)
　Ret	Cy  = 0 成功
		esi = 先頭リニアアドレス
	Cy  = 1 メモリが不足 (esi破壊)
　備考	esi 以外のレジスタ保存

　RAM のアロケーションを行います。確保したメモリの開放は未準備です。
　内部的に set_physical_mem を呼び出しています。

　ずらすアドレスは通常は 0 を指定してください。
　これは、-offset オプションによりベースオフセットが指定されてリンクされた
.exp ファイルロード時に、メモリの先頭指定ページ数に実際のメモリを張りつけな
いで NULL pointer などを参照しようとすると一般保護エラーを出す、という予防
策を張るときのためのルーチンです（バグを防ぐためには大変有効な手段です）。

　引数 esi でずらすアドレスを指定して、戻り値の esi をベースとするセレクタ
を作成すれば、このメモリ状態を自然と実現できるようになっています。

・map_memory
　引数	ds:ebx	+00h d	セレクタ値
		+04h d	物理メモリアドレス
		+08h d	リミット値（ページ数 -1）
		+0ch d	セグメントタイプと特権レベル
		（以降繰り返し）

　セレクタ値に 00h が現れるまでをテーブルと判別し複数のセレクタを作成します。
　セレクタには指定の物理メモリアドレスが張りつけられます。物理アドレスを、そ
れと同じリニアアドレスに張りつけ（リニアアドレスと物理メモリアドレスは1対1）、
そのリニアアドレスをベースとするセレクタを作成します。
　この物理アドレスとリニアアドレスが 1対1 というのはそのうち変更するかも知れ
ません。

　任意の物理アドレス（例えば不連続な物理アドレス）を任意のリニアアドレスに張
りつける場合は、set_physical_mem を使用してください。
　任意のリニアアドレスをベースとするセレクタを作成するときは、make_mems など
を使用してください。

・make_aliases
　引数	ds:esi	+00h d	オリジナルセレクタ値
		+04h d	エイリアスを作成するセレクタ値
		+08h d	セレクタのタイプと特権レベル
		（以降繰り返し）
　備考	esi/edi/ebp 保存

　セレクタ値に 00h が現れるまで、テーブルを参照しながらエイリアスを作成します。
　エイリアスを作成するセレクタ値が既に存在しても構わず上書きされます。

・make_alias
　引数	ebx オリジナルセレクタ値
	ecx エイリアスを作成するセレクタ値
	 al セレクタの特権レベル (00 〜03)
	 ah セレクタのタイプ     (00h〜0fh)

　セレクタのエイリアスを作成します。
　make_aliases から内部的に呼ばれるルーチンですか、単体でも使用できます。
（但し、DS が F386_ds を示していること）

・sel2adr
　引数	eax セレクタ値
　Ret	ebx = アドレス
　備考	eax 以外はレジスタ保存

　セレクタ値を、そのディスクリプタが存在する Free386 DS内アドレスに変換します。

・search_free_LDTsel
　Ret	eax = 空きセレクタ (Cy=0)
	    = 0 失敗       (Cy=1)
　備考	eax 以外はレジスタ保存

　LDT 内から空きセレクタを検索します。
　具体的には P bit（存在ビット）が 0 になってるセレクタを検索します。番号の
小さい方から順にセレクタを検索します。
　LDT 内を全部検索しても空きセレクタが見つからなければ、失敗になります。

;##############################################################################
;## F386sub.asm
;##############################################################################

・register_dump
　引数	   eax	エラーコード
	ds:ebx	レジスタの構造体

　CPU例外発生時にレジスタダンプを表示するルーチンです。合著氏が作成しました。
　詳細は割愛しますが、debug_register_dump と被る部分があるので統合される可能
性は大です。

　CPUが例外に大して返すエラーコードと、例外INT番号を合著氏が混同してしまった
ため一部のコメント文がおかしくなってます。また、CPU例外処理ルーチン(F386int)
がエラーコードを返す CPU-INT とそうでない CPU-INT を区別してないため、改良の
必要があります。

・searchpath
　引数	ds:esi	ファイル名
	ds:ebx	環境変数名
　Ret	eax	= 0 見つかった
		    ds:edi  検索結果ファイルパスとファイル
		= 1 ファイルが見つからない
		= 2 該当する名前の環境変数がない

　指定されたファイルを、環境変数で設定されたパスを参照しながら検索するルーチ
ンです。合著氏が作成されました。
　このルーチン内で .exp を付加した名前を自動的に検索するようになっていますが、
今は呼び出し側で .exp を付加しています。.exp が付いてないファイルを間違って
ロードしないための措置ですが、無駄であることは確かです。

・load_exp
　引数	ds:edx	ファイル名 (ASCIIz)
	ds:esi	バッファアドレス(min 200h)
	   eax	読み込み先セレクタ値
　Ret	Cy = 0  ロード成功
		edx  ロードプログラム EIP
		ebp  ロードプログラム ESP
	Cy = 1  ロード失敗
		al  エラーコード (F386内部エラーコードと同一)

　.exp ファイルをロードします。
　P3ヘッダのフラットモデル形式、その pack 形式、MP ヘッダに対応しています。

・run_exp
　引数	fs	ロードプログラム cs
	gs	ロードプログラム ds
	edx	ロードプログラム EIP
	ebp	ロードプログラム ESP

　load_exp でロードしたプログラムを実行します。
　スタックは呼び出すプログラムの物に切り換えてしまいますので、call しても jmp
してもどちらでも構いません。

・debug_reg_dump
　レジスタをダンプ表示するルーチンです。内部的に ah=09h int 21h を使用してい
ます。
　全レジスタを保存しますので、再入問題が起こるルーチンやハードウェア割り込み
ルーチン以外なら基本的にどこでも使用できるハズです（32bit モードならば）。

・make_cs_ds
　引数	ecx	要求最大量(page)
	esi	読み込み先をずらす量(P3ヘッダ -offset オプション)
　Ret	Cy=0 成功
		実際の割り当て量(byte)を PSP の [60h] に記録
		Load_cs, Load_ds にロード用セレクタの cs/ds 記録
	Cy=1 失敗

　load_exp なら内部的に呼ばれています。
　exp プログラムをロードするための cs / ds を作成し、内部変数や PSPに結果を
記録しています。本来ならもっと抽象度を上げるべきですが、急仕立てだったために
こんな中途半端な使用になりました（汗）。

　マルチ .exp 環境についは、もっとしっかり考えるべきのようです。

;##############################################################################
;## sub.asm
;##############################################################################

　前々から作成していた、汎用的なサブルーチン集です。

・get_parameter (16bit)
　引数を解析します。空白やTABをNULL文字に置き換え、TAB や空白を区切りとする
文字列を、

	paras		dw	0,0		;発見したパラメーターの数
	paras_last	dw	0,0		;0dh の位置
	paras_p		resw	max_paras	;ポインタ配列

に設定します。

	paras_p = *argv[]
	paras   =  argc

と思えば問題はありません。

　最後の CR の位置を記録しているのは、exp 呼び出し時パラメタ文字列を適切に
設定するためです。

・small_to_large (16bit)
・large_to_small (16bit)
　引数	ds:bx	ASCIIz (NULL文字で終わる)

　大文字→小文字、小文字→大文字変換を行います。
　漢字コードなどは特に判別してないので恐らく化けるでしょう。

・hex_to_bin (16bit)
・HEX_conv4  (16bit)
・HEX_conv2  (16bit)

　今のところ特に使われてないので割愛します。
　（でも実行 binary には含まれるのですが(^^;;）

・string_print (32bit)
　引数	ds:edx  NULL文字で終わる文字列

　文字列を表示します。

・bin2deg_32 (32bit)
・bin2hex_32 (32bit)
　引数　   eax	変換する数値
	ds:edi	文字列を記録するアドレス
	    cl	変換する桁数
　Ret	   edi	最後の桁の文字アドレス +1 を示す

　数値を10進数、16進数に変換します。edi 以外のレジスタは全て保存します。
　速度を気にしないで、10進数変換は div を使用しています。等価な mul に置き換
えた方が速いでしょう。

;##############################################################################
;## start.asm
;##############################################################################

　Free386.asm (.obj) を最後にリンクしなければならない関係上、.com ファイルを
作成する都合で作成したファイルです。

　今では、動作定義変数を記述したり、ディバグ用の領域を確保したりしてます。デ
ィバグ領域を確保するときは、DOS←→Protect仲介バッファ（F386DEF内int_buf_size）
をその分小さく設定することを忘れないでください。

;##############################################################################
;## 機種依存処理のソース
;##############################################################################
-------------------------------------------------------------------------------
towns.asm
pc98.asm
at.asm
-------------------------------------------------------------------------------

　仕組みは非常に簡単です。

　まず、Free386.asm から機種判別ルーチン
	call	check_TOWNS		;TOWNSか判別
	call	check_PC98		;PC-98x1か判別
	call	check_AT		;PC/AT互換機か判別
が呼ばれます。これらは 16bit ルーチンです。
　戻り値は Cy=0 で該当機種、Cy=1 で他機種という方式です。

　次に F386prot.asm 内から
	call	setup_TOWNS
	call	setup_PC98
	call	setup_AT
が呼ばれています。これらは 32bit ルーチンです。

　この中で初期化処理を行っています。towns.asm では TOWNS固有のセレクタ、T-BIOS
などを配置しています。

　終了処理は、Free386.asm 内の END_program で呼ばれています。
	call	end_TOWNS
	call	end_PC98
	call	end_AT

;#############################################################################
;#############################################################################
;#############################################################################

;#############################################################################
;## エラーコード処理法
;#############################################################################

　V86 モードで発生したエラーは、そのままエラーメッセージを表示して終了して
います。
　プロテクトモードで発生したエラーは、"f386err" という byte型の内部変数に内
部エラーコードを記録して終了しています。プログラムが返す errorlevel は、
int 21h / ah=4ch のところで、これまた内部変数に記録しています。

　F386_end というマクロは指定した値は、内部エラーコードとして記録しプログラ
ムを終了しています。

　記録された内部エラーコードは、V86モード(DOS)での終了処理の直前でチェック
され、テーブルからエラーコードに対応するエラーメッセージを表示し終了するよ
うになっています。

・内部エラーコードリスト

	00h-1fh		欠番（以前のバージョンの名残から使用できない）
	20h		欠番
	21h		プロテクトメモリがない
	22h		実行ファイルの読み込みに失敗
	23h		実行ファイルをロードするメモリが不足
	24h		実行ファイルの形式が不正

　欠番は、仕様変更で意味がなくなったもの、またCPU例外を内部エラーコードで処
理していたときの名残です。

;#############################################################################
;## メモリ管理方法
;#############################################################################

F386data.asm より
	free_LINER_ADR	dd	0	;未定義(未使用)リニアアドレス (最低位)
	free_TABLE_ladr	dd	0	;ページテーブル用リニアアドレス(未使用)
	free_RAM_padr	dd	0	;空き先頭物理RAMページアドレス
	free_RAM_pages	dd	0	;利用可能な物理RAMページ数 (4KB単位)

・RAM管理方法

　XMSメモリのロックによって得られた、１つの連続した物理アドレスを持つプロテ
クトメモリは、まず初めに開始アドレスが "free_RAM_padr" に、空きページ数が
"free_RAM_pages" に設定されます。
　なお開始アドレスには、予めページテーブルに書き込む時用に 7 が or されてい
ます。これはページテーブルの存在ビットなどです（詳細はCPU資料参照）。

　メモリを 1page 使うごとに、free_RAM_padr のアドレスが 4KB 加算され、
free_RAM_pages が 1(page)減算 されます。解放は現在のところ考えられていません。

　メモリは常に低位から上位に向かって使用されていきます。


・メモリアドレス管理方法

F386DEF.inc より
	USER_Start_adr	equ	400000h	;ユーザ用リニアアドレスの開始番地
	Unit_of_MEM	equ	400000h	;メモリアドレスの割り当て単位(/byte)
	MIN_heap_mem	equ	200000h	;最小ヒープリニアアドレス

　VCPI によってページテーブル#000 を初期化すると、0MB〜1.1MBのページテーブ
ルが設定されます。このとき、ユーザが定義可能なアドレスの開始番地が内部的に
算出され、一度 free_LINER_ADR に記録された後、最終的に free_TABLE_ladr に
記録されます。

　この空きメモリ番地から USER_Start_adr (4MB) までがページテーブル用のメモ
リアドレスとして予約され、ユーザプログラムなどのアドレス領域はこの 4MB 以降
の領域に割り当てられます。
　この予約したページテーブル領域で、約 3GB までのRAM に対応できるハズです。

　具体的には free_LINER_ADR に 4MB のアドレスが設定されます。これは常にユー
ザプログラムが使用できるフリーなリニアアドレスの開始番地を示しています。
　物理メモリのマッピングを考えなければ、

	start	size	使用者
	+ 4MB	2MB	program A
	+ 6MB	4MB	program B
	+10MB	7MB	program C
	+17MB	1MB	program D

とすればいいのですか、これでは program A〜C が自分のセレクタの後ろに物理メモ
リをマッピングしようとしたとき上手くいきません（失敗します）。

　ですから、Free386 ではこのメモリ管理を 4MB (Unit_of_MEM)単位で行っています。

	start	size	使用者
	+ 4MB	2MB	program A
	+ 8MB	4MB	program B
	+12MB	7MB	program C
	+20MB	1MB	program D

　こうすることで、各プログラムの後ろにアドレス領域に余裕ができます。
　しかしこれだけでは、program B だけは物理メモリのマッピングができません。ま
た、program C が 1.5MB のメモリをマッピングしようとすると失敗します。
　ですから、Free386 では最低限 2MB(MIN_heap_mem) のメモリをアドレス余裕とし
て補償しています。

	start	size	使用者
	+ 4MB	2MB	program A
	+ 8MB	4MB	program B
	+16MB	7MB	program C
	+28MB	1MB	program D

　ちょっと考えればわかりますが、この管理は大体において大丈夫でも、決して万全
ではありません。

　マルチタスクには本格的なメモリ管理が不可欠ですが、その機構は複雑になりそ
うです。
　DOS-Extender はあくまで簡易なメモリ管理を行い、本格的な操作は kernel プロ
グラムに任せる方向で考えています。まだまだ先の話ですが。

;#############################################################################
;## ソースを読むポイント
;#############################################################################

　基本的には、ほとんど全てに説明を書いてありまので、アセンブラを読めて DOS や
プロテクトモードの予備知識がある方は、おそらく問題なく読めるのではないかと思
います。
　コメントがくど過ぎるという説もあるようですが（苦笑）、全くないのよりはマシ
ということにしましょう。

○よく使うマクロ

　NA386 からアセンブラに入ったので疑似命令をほとんど知らないというのもありま
すが、マクロはほとんど使用しません。
　基本的にアセンブラに依存するようなことは好きではないのですが、NASM はフリー
ということもあり、部分的にはそのマクロを積極的に利用しています。しかし、そん
なに悩む程ではないと思います。

　私がアセンブラを使う際に、よく使うマクロを挙げておきます。
　nasm_abk.h に書かれてる内容なのですが。ソースを読まれる方は、まず初めにこの
ファイルに簡単に目を通しておくことをお勧めします。

	定義	内容
	b	byte
	w	word
	d	dword
	callf	call dword far	（注:16bit モードで使用しないこと(;_;

　callf 以外は多用してます。慣れないと最初は読みにくいかも知れません。

	public	global
	offset

　他のアセンブラと互換のために定義しています。
　offset については、"明示的に意味を示す" 目的で積極的に記述しています。


○言葉の定義（コメント等）

オフセット	ds: て参照される対象のアドレス。アドレスと書く場合もあるかも？
		修飾：_offset, _off, _adr または修飾なし

リニアアドレス	線形空間アドレス。
		修飾：_liner, _ladr など

物理アドレス	実メモリ空間のアドレス。
		修飾：_p

table0等	ページディレクトリにエントリされてる、N 番目のページテーブル

　他にもありますが……。
　i386 プロテクトモードの特徴ですが、アドレスがセレクタ内アドレス、リニアア
ドレス、物理アドレスと３種類ありますので読むときは混同しないように気を付けて
ください。

　ページング関連のソースを読むのはかなり辛い作業だと思います。
　書いた本人も、途中何度も混乱しましたから……。


○スタック参照

　int処理の部分では、スタック参照やスタック内データの書き換えを多用しています。
　再入可能にするためには、結局スタック以外にデータを置くところがなかった……
というところです。

	push	eax
	push	ebx
	push	ecx
	mov	edx,[esp   ]
	mov	esi,[esp +4]

　としたとき、edx/esi にはそれぞれ何が代入されるか？
　こういうスタックの構造に慣れてないと非常に読みにくいと思います。正解は、そ
れぞれ ecx/ebx となります。
　esp はスタックのトップを示すことをよく頭に入れたおいてください。

	push reg =
		sub	 esp ,4
		mov	[esp],reg
	pop reg =
		mov	 reg,[esp]
		add	 esp,4

　また、ebp/esp のディフォルトセレクタは ss です。
　これも混乱しないように注意してください（それ以外の汎用レジスタは ds です）。

○NASM と 他のアセンブラの即値解釈

　アセンブラでは即値として文字列を使用することが出来ます。

	mov	eax,'F386'

　しかし、この解釈は NASM と他のアセンブラでは異なります。この点は十分に注意
してください。

	NASM:
		dd 'F386'  ＝  db 'F', '3', '8', '6'
	MASM, 386|ASM:
		dd 'F386'  ＝  db '6', '8', '3', 'F'

;#############################################################################
;## よく使われるテクニック
;#############################################################################

　テクニックと言えるほど大したものではありませんが、一応書いておきます。

●mov eax,0
	= xor eax,eax
	こうすることで、命令長が短くなります。

●上位ビットのクリア

　例えば、cl に INT 番号が入ってたとします。
　INT番号からテーブルを参照しようと table + cl*4 のアドレスを参照するとします。

	movzx	ecx,cl			;上位ビットのクリア
	shl	ecx,2			;4倍
	mov	eax,[table + ecx]	;テーブル参照

というように、アドレスの部分に指定できるのは ecx など 32bitレジスタのみです。
　ですから、ecx の bit 31-8 に変な値が設定されていると、とんでもないアドレス
を参照しかねません。

　通常はこのような記述で構いませんが、ループ内で cl などのレジスタへの代入、
データ参照を繰り返すときは

	xor	ebx,ebx			;ebx = 0
.loop:	：
	：
	mov	bl,ah			;
	mov	eax,[table + ebx]	;テーブル参照

というようなことをしています。
　単なる計算でも、32bit レジスタを指定する必要があるときはこのような方法を
取っています（32bit と 16bit/8bit レジスタの加算などはできない）。

●アドレス指定

　i386 のアドレス指定を多用しています。
　i386 には強烈なアドレス指定があり、一度マニュアルの該当箇所を参照すること
をお勧めします。

	S[140][8] という配列の S[X][Y] を参照するとき。

	mov	ebx,Y
	mov	eax,X
	mov	edx,[S + eax*8 + ebx]

　ここまて複雑なことはしてませんが、このようなアドレス計算は多用しています。
　i386 CPU にはアドレス計算専用のユニットが詰まれているため高速に計算されます。

　逆にこれを利用して

	lea	ebx,[XXX + eax*8]

という計算をする場合もあります。lea は [] の計算結果をそのままロードする特殊
な命令だと思ってください（厳密な意味はマニュアル参照のこと）。

　ちなみに、この命令を効率的に使用すると積算や加算を高速に実現できます。

●スタックジャンプ

　これはアセンブラを使う人なら使い古された手段なのですが。スタックの構造をよ
く理解してないと何をやってるのか分からないでしょう。

	call	LABEL1
XXX:	jmp	LABEL2

　という命令を考えてみます。

	call	LABEL1	＝	push	offset XXX
				jmp	LABEL1

	ret		＝	pop	[data]
				jmp	[data]

　この左右が全く等価であることを理解すれば簡単な話です。
　ret で jmp する機能があるのですから、

	push	offset LABEL2
	jmp	LABEL1

としてしまえば同じことです（分かるかな？）。

	jmp	eax

といったことは出来ませんので、このスタック参照jmp は強烈な技となります。
　レジスタを上手く保存しながら目的のラベルに jmp しようと思ったら、スタック
を書き換えるのが一番効率的です（メモリに jmp 先を書き出すと、再入不可能に
なったり、競合問題が発生することがあります）。

　F386int.asm などでは、このスタック参照jmp を上手く使用しています。

　ちなみに応用として、

	call	LABEL1
	call	LABEL2
	call	LABEL3
	jmp	LABEL4

とあったら、

	push	offset LABEL4
	push	offset LABEL3
	push	offset LABEL2
	jmp	LABEL1

とすることも出来ます。

;#############################################################################
;## 使用ツールとディバグ方法について
;#############################################################################

・ms.com
	各種のメモリ状況を表示する非常に高機能なツールです。DOS汎用です。

・ddeb
	386レジスタや386命令に対応した DOS汎用ディバガ です（use32 は非対応）。
	フリーソフトです。

　どちらもベクターにあります。


　DOS におけるディバグ ddeb ですべて用が足りました。
　ただ、プロテクトモード切り換えの部分を trace してるとハングアップするのと、
XMSメモリを確保後、ついうっかり 'q' と入力してディバガを終了させるとプロテク
トメモリが専有されたままになるので（要リセット）注意してください。


　Protect モードのディバグは、int 3 などを埋め込んで強制的にレジスタを吐かせ
たり、DEBUG_1 (F386DEF.INC) を使用してレジスタを表示されせりして行いました。

　また表示が困難なものについては、start.asm で確保した領域へ観察したいデータ
を書き出し、プログラム終了後にディバガからメモリダンプして確認しました。


　それでも確認できない、ハングアップしてしまうようなもののディバグは、TOWNS
の FASTモードランプ を使用しました。
　マクロを見ると、
	SPEED_N / SPEED_F
というものがあると思いますが、FAST ランプが消えるのを確認しながらどこまでは
実行できているか確認しつつディバグをしました。
（そのままハングアップするので、その後リセットか必要なのですが……）


;#############################################################################
;## 最適化について
;#############################################################################

　最適化というほどでもありませんが、一応多少は速く動くようにように設計して
います。
　386 はあんまり考えてないのですが、486以降で速く動くことを主眼に置いて、そ
の上で pentium でもペアリングが効くように考慮してます（一部、ソースの見やす
さを取った部分もありますが）。

　pentium 最適化をしまくると、486/386 では劇的に遅くなることがあるので、そう
いうものは控えてます。

　また命令コードを小さいすること、レジスタの保存などの関係から string 命令も
（例：rep movsd）積極的に使用しています。
　pentium 以降は展開した方が速いのですが、jmp 命令が増えますし、レジスタの
消費も激しいし、ソースも読みにくくなるのでやめました。

　pntium より後のCPU（MMX pentium/K6 以降）は、私の方が知識を持ち合わせてい
ませんので最適化はナシと考えて問題ないでしょう。

　また命令コードは極力小さくするように考えて書かれています。
　というのも、最近のAT機ならまだしも TOWNS/PC-98 といったマシンではメモリア
クセスが非常に遅く、命令コードの増加は単なる 所要clock数 では割り切れないも
のがあると考えるからです。

　総括すると、486／AT以外の機種ともに「遅いマシンで速く動けばいい」という感
じで、「遅いマシンで速く動けば、速いマシンでもそれなりに動く」ということです。

　気に入らない方は、ソース付きですから適当に改造してください。
　希望があれは、結果はマージします。

;#############################################################################
;## 参考文献
;#############################################################################

○プロテクトモードについて

・80386プログラミング　工学社　3500円(+税)
	John H.Crawford＋Patrick P.Gelsinger著　岩谷宏／訳

　CPUのマニュアルのようなものです。設計者の一人が執筆してます。
　前半がニモニック説明、後半はプロテクトモードやら、V86モードやらの説明が
詳細にされています。
　一応これがあれば過不足なく足りると思われます。
　私はこれを使用しました。良書かどうかは比較したことがないので分かりません。
また、486以降の資料が載ってないのが難点です。

・初めて読む486　アスキー出版　蒲地輝尚著　2427円(+税?)

　プロテクトモードの基礎知識となる、ページング機構、セレクタ、リング保護など
が親切丁寧に分かりやすく解説されています。アセンブラの基礎知識があれば問題な
く読めると思われます。
　おそらく「80386プログラミング」などをいきなり読んでも、その全容は理解でき
ないと思われます（私はそうでした）。中には理解できる人も居るのでしょうが……

　入門書として最適ですが、プログラミング資料しとては役不足ですので、図書館で
借りて読むのが吉（笑）

・MS-DOS基本プログラミング第6集
　X86プロテクトモードプログラミング　CQ出版　2500円(+税)

　DOSでプロテクトモードを活用することをテーマに、拡張メモリアクセスに始まり、
XMS、プロテクトモードの基礎知識、VCPI、DPMI と解説されています。 
（DPMI Ver0.9 / XMS Ver2.0。付属ディスクに XMS3.0 で追加されたファンクション
の説明がある）

　あくまで「DOS での活用」が main ですので、プロテクトモード自体とは外れる話
もあります。プロテクトモードに関する説明もありますが、この本の解説は読んだこ
とがありませんので何とも言えません。
　CQ出版ですので悪くはないと思いますが、ページ数は余り多くありませんで全てを
理解するのには多少難しいかも知れません。

　VCPI の利用法はこの本によりました。
　プロテクトモードの解説本というより VCPI/DPMI の日本語資料として貴重かも知
れません。

・インテルの公式資料

　よく知らないのですか、http://www.intel.co.jp/ 辺りで CPU の資料は配ってい
るハズです。pdf 形式だと思いますので、これを印刷すれば一番安上がりだと思わ
れます。
　プロテクトモードについてどの程度載っているかは参照したことがないので知り
ません（汗）

○DOS-Extender について

・FM TOWNS 386|DOS-Extender V1.2aJ ユーザーズマニュアル

　いわゆる TOWNS RUN386 のマニュアルですが、借り物だったりします(^^;;;
　DOS function / DOS-Extender function リストの他、DOS-Extender 環境について
説明があります（詳細に説明されてはいません）。貴重な資料であることは確かでし
ょう。

・EXE386 体験版付属テキストマニュアル

　プログラムの作成は、主にこっちを参照しまた。
　合著氏の書いた DOS-function リストと一緒に印刷してホチキスで閉じた状態で目
の前に置いてあります。

　上の RUN386 のマニュアルがなくても、こちらがあればほとんど用は足りると思わ
れます。

・High C(R) Compiler 開発キット V1.7 ユーティリティ解説書  / HCK17UK.DOC

　MPヘッダ、P3ヘッダの資料が載っています（これだけで不十分の面もありますが）。
　また、リンカの動作やオプションが詳細に載っています。.exp のロード部はこれ
を参照しました。


○DOSの資料

・MSDOS.TXT DOSFUNC.TXT    (C)合著@ABK

　合著氏が作成された、DOS-function や DOS-MCB（メモリコントロールブロック）に
関する資料です。UNDOCUMENTED な function も含みます。
　Free386 の DOS ファンクション処理部は、ほとんどこちらを当たりました。

　ABK の ftp サーバ（ftp://ftp.abk.nu/pub/）にて公開されています。

・Interrupt List

　英語で書かれた、DOS系システムのあらゆる function list です。
　UNDOCUMENTED なファンクションや、DOS の UNDOCUMENTED な資料を含みます。大変
貴重な資料です。
　ベクターにあるはずです。なくても検索すればすぐに出てきます。

・日本語MS-DOS V3.1 プログラマーズリファレンス

　MS-DOS 拡張機能に付属していたマニュアルです。
　私が持っているのは FMシリーズ用 ですが（秋葉原の某ショップでタダでもらって
きました）、どの機種用でもほとんど同じです（以前 OKI 用のを見たことがあります
が、体裁まで一緒でした）。

　DOS function リストの他、デバイスヘッダの解説、EXEヘッダの解説、インテルobj
の解説など詳細な DOS 資料が提供されています。ジャンク屋などで見かけたらぜひ手
に入れることをお勧めします（個人的には Ver 6.2 のものが欲しいのですが……）。


○メモリサーバの資料

・XMS30J.TXT / XMS Ver3.0 ファンクションコール一覧

　自分で書いたものですが（汗）
　これも、ABK の anonymous-ftp サーバで公開されています。

　XMS の読んで理解するつもりでこのファンクションコールリストを作成しました。
　作成にあたり色々の本を参照しましたが、作成後はコイツを参照しながらプログラ
ムを作成しました。
　個人的には、これだけあれば XMS は十分のような気がします。

・その他

　使用してないものもありますが、EMS 4.0 / XMS 3.0 / VCPI 1.0 / DPMI 1.0 につ
いて資料が配布されてますので（英語）、比較的簡単に手に入ります（英語を読む気
力があればの話ですが）。
　MSCDEX のファンクションリストも転がっていますので、MSCDEX を使ったCDライブ
ラリを誰か作って頂けると助かります。

　暇があったら ABK のサーバにも転載しておきます。

　資料の問い合わせについても応じます。持っている限りの資料は提供します。別に
Free386 とは関係なくても構いませんので、御相談ください。


○各機種の情報

　TOWNS は FM TOWNS テクニカルデータブック。
　PC-98 はネットでタダで配ってる、テクニカルデータブックの本になれなかったテ
キストファイル。
　AT互換機は現在も捜索中……といったところです。

・AT互換機のハードウェア全般
・PC-98 に搭載されているグラフィックボードの資料
・FM TOWNS の非公開I/O や OSの仕様 など

　最終的には Linux のソースを読むしかないか……と思ってますが。

・UNDOCUMENTED DOS

　探してる本です。訳書です。12800円ですので、とてもじゃないけど買う気になれま
せん（それ以前に出版社にもなさそうですが / 1995年発行）。

