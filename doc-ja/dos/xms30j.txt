===============================================================================
	XMS Ver3.0 ファンクションコール一覧
					2001/02/10	Written by nabe@abk
===============================================================================
[TAB=8][Shift-JIS]

　XMS Ver3.0 のファンクションリストです。XMS2.0 の日本語資料は（出版物などで）
比較的容易に手に入りますが、XMS3.0 の日本語資料が見当たらないため簡単に纏めま
した。

　作成にあたり、簡潔で分かりやすいことを心がけました。
　そのために、日本語資料から分かりやすい記述を参照しています。作成後、簡単で
はありますが XMS仕様書原文(XMS30.TXT) で確認しています。しかし、本テキストは
XMS3.0 の翻訳ではありませんのでご注意ください。

　なお本資料の配布・転載・抜粋・流用などは完全に自由とします。
　また不明な点は、メール又は以下の資料などを参照ください。

	"eXtended Memory Specification (XMS), ver 3.0 January 1991" / XMS30.TXT


///////////////////////////////////////////////////////////////////////////////
●XMSの確認方法 / INT 2fh
	IN	AH = 43h
	  	AL = 00h
	Ret	AL : 80h  XMS在り
		     Any  XMSなし

●XMSエントリポイントの獲得 / INT 2fh
	IN	AH = 43h
	  	AL = 10h
	Ret	ES:BX	XMSのエントリポイント (far call address)

	XMSエントリポイントを far call することで、
	XMSファンクション呼び出しを実現する。

///////////////////////////////////////////////////////////////////////////////
■ XMS function 共通 ■

　00h 以外の XMS function はエラー時、AX=0000h BL=Error Code を返します。
　以下のファンクションリストでは、この記述を割愛しています。これは、エラー発
生時に BL が破壊されることを意味しますので『くれぐれも注意』してください。
　　　^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
　エラーコードは以下のように定義されています。
　ファンクションにより返されるエラーコードは決まっておりますが、それについは
XMS仕様書原文などを参照ください。

	80h	要求されたファンクションは実装されていない
	81h	VDISK.SYS のデバイスドライバが拡張メモリを先に使用している
	82h	A20ラインゲート操作でエラー発生
	8Eh	一般的なドライバエラー
	8Fh	回復不可能なドライバエラー
	90h	HMA が存在しない
	91h	HMA は既に使用されている
	92h	HMA 要求サイズが、最初割り当て設定値(/HAMIN) よりも小さい
	93h	HMA は割り当てられていない
	94h	A20ラインは既に使用可能
	A0h	EMB:使用可能な拡張メモリはすべて割り当てられている
	A1h	EMB:使用可能な拡張メモリ用ハンドルがすべて使用されてる
	A2h	EMB:無効なEMBハンドルが指定されている
	A3h	EMB:転送元ハンドルが無効
	A4h	EMB:転送元オフセットが無効
	A5h	EMB:転送先ハンドルが無効
	A6h	EMB:転送先オフセットが無効
	A7h	EMB:転送サイズが無効
	A8h	EMB:転送元とメモリ領域と転送先メモリ領域が重なっている
	A9h	パリティエラー
	AAh	EMB:ロックされていない
	ABh	EMB:ロックされている
	ACh	EMB:ロックカウントがオーバーフローした
	ADh	EMB:ロック失敗
	B0h	UMB:指定サイズよりも小さいメモリブロックなら使用できる
	B1h	UMB:使用可能なUMBメモリが存在しない
	B2h	UMB:UMBセグメントアドレスが不正である

-------------------------------------------------------------------------------
●00h：XMSバージョンの取得
	IN	AH =  00h
	Ret	AH.AL XMS仕様 のバージョン (Exp : 3.00, 2.00)
		BH.BL ドライバのバージョン
		DX=1  HMA機能 在り
		  =0  HMA機能 なし

	※エラーは起きない。

-------------------------------------------------------------------------------
●01h：HMAの割り当て
	IN	AH = 01h
		DX = HMA必要サイズ (byte)
	Ret	AX = 1 成功
		     0 失敗

●02h：HMAの開放
	IN	AH = 02h
	Ret	AX = 1 成功
		     0 失敗

※HMA は 最大で 65520 byte (=64 kbyte - 16 byte) 割り当てられる。
　HMA のベースアドレスは 100000h(例 FFFF:0010)。
　一度確保された HMA は開放されるまで二度と使用できない。

　DOS 5 以降では、DOS が HMA をすべて確保し管理している (DOS=HMA 時)。

-------------------------------------------------------------------------------
★★★ A20ライン管理ファンクション・グループ ★★★

●03h：A20ラインのグローバルな有効化
	IN	AH = 03h
	Ret	AX = 1 成功
		     0 失敗

●04h：A20ラインのグローバルな無効化
	IN	AH = 04h
	Ret	AX = 1 成功
		     0 失敗

●05h：A20ラインのローカルな有効化
	IN	AH = 05h
	Ret	AX = 1 成功
		     0 失敗

●06h：A20ラインのローカルな無効化
	IN	AH = 06h
	Ret	AX = 1 成功
		     0 失敗

●07h：A20ラインの状態問い合わせ
	IN	AH = 07h
	Ret	AX = 1 有効
		     0 無効

※実際の出力値 A20 は以下のように決定される。

	swich (AH) {
		case 03h: GA = 1; break;
		case 04h: GA = 0; break;
		case 05h: CNT++ ; break;
		case 06h:if (CNT) CNT--;
	}
	A20 = GA | CNT;  /* A20==0:無効  A20!=0:有効 */

　なお、HMA 使用中は A20 を設定すべき。

　備考：A20 とは CPUアドレスライン の bit20 のことで、
　　　　互換性のためこのラインを強制的に 0 にする機能が (PCに) 備わっている。

-------------------------------------------------------------------------------
★★★ EMB管理ファンクション・グループ ★★★

	この部分は 80286 時代に作成された仕様(XMS2.0)ですので、
	定義されたファンクションの仕様上 64 MByte 以上のメモリ管理できません。
		>>08h,09h,0Eh,0Fh

	※EMB：拡張メモリブロック。110000h番地以降のメモリのこと。

●08h：EMB空きメモリの問い合わせ
	IN	AH = 08h
	Ret	AX = 0以外
		     AX = 連続領域として確保できる最大サイズ (Kbyte)
		     DX = トータルの空きメモリサイズ (Kbyte)
		AX = 0 失敗
		     DX = AX が 0 ということは、↑から DX=0

●09h：EMBの割り当て
	IN	AH = 09h
		DX = 割り当て要求サイズ (Kbyte) / DX=0 も可
	Ret	AX = 1 成功
		     DX = EMBハイドル (内部ポインタのことが多い)
	   	AX = 0 失敗

		※ハンドル数には限りがあるため（0Eh で確認できる）
		　小サイズのメモリを複数確保するべきではない。
		　１つのアプリでいくつかの大きなブロックを確保し、
		　そのブロック内をアプリ側で使い分けるべきである。

●0Ah：EMBの開放
	IN	AH = 0Ah
		DX = EMBハンドル
	Ret	AX = 1 成功
	   	   = 0 失敗

●0Bh：EMBデータ転送
	IN	AH =  0Bh
		DS:SI データ構造体 (16 byte)
	Ret	AX = 1 成功
	   	   = 0 失敗

		DS:SI データ構造体 (16 byte)
		 +00h d 転送サイズ (byte)
		 +04h w 転送元 EMBハンドル
		 +06h d 転送元 オフセット
		 +0Ah w 転送先 EMBハンドル
		 +0Ch d 転送先 オフセット

		DOS(1MB) メモリ空間を指定する場合は、以下のようにする。
			EMBハンドル  w 0
			オフセット   w OFF
			オフセット+2 w SEG

●0Eh：EMBハンドルの情報取得
	IN	AH = 0Eh
		DX = EMBハンドル
	Ret	AX = 1 成功
		       BH = ロックカカウンタの値 / if BH=0 unlaocked
		       BL = 使用可能な空きEMBハンドル数
		       DX = ブロックサイズ (Kbyte)
	   	AX = 0 失敗

●0Fh：EMBのサイズ変更
	IN	AH = 0Fh
		BX = 新たなメモリブロックのサイズ (Kbyte)
		DX = EMBハンドル
	Ret	AX = 1 成功
	   	   = 0 失敗

-------------------------------------------------------------------------------
★★★ EMB管理ファンクション・グループ (require XMS3.0) ★★★

	このグループは 80386 向けに拡張されたときに(XMS3.0)定義されたものです。
	内容的には 08h,09h,0Eh,0Fh の拡張となっています。
	（若干ですか追加およびレジスタの変更がありますので注意が必要です）

●88h：EMB空きメモリの問い合わせ
	IN	AH = 88h
	Ret	BL = 00h:成功
		     	EAX = 連続領域として確保できる最大サイズ (Kbyte)
			ECX = 管理するメモリブロック最上位アドレス
			EDX = トータルの空きメモリサイズ (Kbyte)
		BL !=00h:エラー
		        BL = A0h のとき
			     EAX = EDX = 0
		        BL = A0h か 81h のとき
		             ECX = 管理するメモリブロック最上位アドレス

●89h：EMBの割り当て
	IN	AH  = 89h
		EDX = 割り当て要求サイズ (Kbyte) / DX=0も可
	Ret	AX  = 1 成功
		      DX = EMBハイドル
	   	AX  = 0 失敗


●8Eh：EMBハンドルの情報取得
	IN	AH = 8Eh
		DX = EMBハンドル
	Ret	AX = 1 成功
		       BH  = ロックカカウンタの値 / if BH=0 unlaocked
		       CX  = 使用可能な空きEMBハンドル数
		       EDX = ブロックサイズ (Kbyte)
	   	AX = 0 失敗

●8Fh：EMBのサイズ変更
	IN	AH  = 8Fh
		EBX = 新たなメモリブロックのサイズ (Kbyte)
		DX = EMBハンドル
	Ret	AX = 1 成功
	   	   = 0 失敗

-------------------------------------------------------------------------------
★★★ UMB管理ファンクション・グループ ★★★

　UMB は、よく"ハイメモリ"と呼ばれるものです。

●10h：UMBメモリブロックの割り当て
	IN	AH = 0Ch
		DX = 割り当て要求サイズ (PARA = 16byte単位)
	Ret	AX = 1 成功
		       BX = 割り当てられたブロックの先頭セグメント
		       DX = 割り当てられたブロックのサイズ (PARA = Size/16)
	   	AX = 0 失敗
		       DX = 最大使用可能ブロックサイズ

●11h：UMBメモリブロックの開放
	IN	AH = 0Dh
		DX = 開放するブロックの先頭 PARAアドレス
	Ret	AX = 1 成功
	   	   = 0 失敗

-------------------------------------------------------------------------------
★★★ EMBのロック・アンロック ★★★

　本来は EMB の管理グループに含まれるのですが、本文章では別項にしました。

●0Ch：EMBメモリブロックのロック
	IN	AH = 0Ch
		DX = EMBハンドル
	Ret	AX = 1 成功
		       DX:BX メモリブロック先頭の物理アドレス (32bit)
	   	AX = 0 失敗

●0Dh：EMBメモリブロックのアンロック
	IN	AH = 0Dh
		DX = EMBハンドル
	Ret	AX = 1 成功
	   	   = 0 失敗

※ロックの状態は以下のように決定される。

	if (AH=0Ch)                 LOCK_COUNT++;
	if (AH=0Dh) if (LOCK_COUNT) LOCK_COUNT--;
	/* LOCK_COUNT == 0 :アンロック  LOCK_COUNT != 0 :ロック */

　ロックされたメモリブロックは、再割り当てファンクションによる移動発生時や開
放ファンクションによるメモリ開放に失敗します。また、メモリの確保と開放により
断片化されたメモリ領域の整理のため XMS Driver側が内部的にメモリを再配置しな
くなります。

　これにより、特定の物理アドレスを安心して専有的に使用できます。EMS エミュレー
タや、DOS-Extender には絶対に欠かせない機能です。が、XMSアプリケーョンプログラ
ムを作成する際には全く必要のない機能です。

　内部的なメモリ再配置を行うかはメモリドライバの作成者に任されており、「DOS 5
付属のドライバは再配置を行わないようだ」と記述のあった文献もありました。

　なお、XMS2.0 の記載に従い "物理アドレス" のところを "リニアアドレス" と記述
してる文献以外見当たりませんでしたが、XMS3.0 において該当部分は "物理アドレス"
と書き改められています。
　これは80386以降のページング機構を使用した場合において 物理アドレスとリニアア
ドレスは１対１に対応しない（つまり指し示す意味が違う）ためです。

　アドレスが得られる（レジスタに値が設定される）こと自体記述されてなかった文献
もあったことを付け加えておきます。

/////////////////////////////////////////////////////////////// end of function
///////////////////////////////////////////////////////////////////////////////

※この項は（断定的な文調であっても）個人的な推論です。十二分にご注意ください。
　現時点では特に解析したわけではありません。

■HIMEM.SYS と EMM386.EXE について

　随分と昔から、DOS に最初に触れたころから謎な存在でしたが

	HIMEM.SYS	XMS(UMB機能除く) / 1MB 以上の全てのメモリの管理
	EMM386.EXE	EMS / VCPI / DOSを仮想86モードに切り替え
			XMSのうちUMB機能

　ということらしいです。
　試してみると分かることですが、
　HIMEM.SYS を組み込んだだけでは DOS はリアルモードで動作します。
　emm386.exe を組み込んで初めて CPU がプロテクトモード (V86モード含む) に
移行します｡

■HIMEM.SYS

　HIMEM.SYS、つまり XMS Driver 自体は リアルモードでも動作するように作られた
プログラムだということです。おそらくは拡張メモリ (EMB) にアクセスするときのみ、
CPU をプロテクトモードに切り換えているのではないでしょうか。

　拡張メモリアクセスとしては、PC-98 シリーズの int 1fh BIOS、PC/AT 互換機の
int 15h がありますが、概念的にはこれらの BIOS機能＋拡張メモリ管理といった感
じだと思います。

　HIMEM.SYS はあくまで拡張メモリの管理ドライバにすぎない。
　これはどういうことかと言うと、CPU 動作モードやページング機構などは管轄外で
あり、あるメモリ領域の使用許可を出すだけのシステムと言えるでしょう。

　くどいようですが DOS においては HIMEM.SYS がメモリの絶対的な管理者です。

　XMZ driver という PC-98 用の XMS2.0 のメモリドライバ (ソース付き) をみまし
たが、メモリ転送には PC-98 の int 1fh-BIOS を呼び出し、ドライバ自体は本当に
管理を行ったるだけでした。
　ちなみにこの XMZドライバ、DOS 5 の HIMEM.SYS と置き換えることができます。

	HIMEM.SYS 	DOS 5.x : XMS Ver2.0
			DOS 6.x : XMS Ver3.0

■EMM386.EXE

　XMS Driver の存在を前提としたデバイスドライバです。
　EMM は Extended Memory Manager の略です

　少し歴史的な話をすると、元々は単なる EMS Driver でした。EMS は LIM EMS

	Lotus/Intel/Microsoft (LIM) Expanded Memory Specification (EMS)

と呼ばれ、Lotus と Intel と Micorsoft が一緒に作成した拡張メモリの規格です。
Lotus が大規模アプリケーションを作成する際、8086/80186CPU の DOS 環境にお
ける利用可能なメモリ（コメンベンショナルメモリ = 640KB）では足りなくなった
ために、それを補う方策として制定された規格と言われています。

　その当時の拡張メモリとは、今のような 1MB 越えのメモリではなく、ROM領域
として定義されていた 384KB のメモリ内に RAM の領域を切替えながら出現させ
ようというものでした。
　これが、一般にバンクメモリと呼ばれるもので、そのバンクメモリ機能を搭載
した拡張カードが登場しました。EMSカードと呼ばれるものです。

　その後 CPU が 80286 になり 16MBまでの物理メモリを管理できるようになり、
80386 の登場で 4GB までのメモリとページング機構が使えるようになりました。
　これにより EMM には、バンク切替えではなくソフトウェアによるメモリ転送を
用いて、バンクメモリの仕様を再現（エミュレーション）するものが現れました。
自力で CPU 動作モードを切り替え、拡張メモリ（1MB越えのメモリ。以降同じ意味
で使用）にアクセスする方法です。

　しかし、80286 や 80386 の登場と同時に XMS2.0 / XMS3.0 という規格も登場し
ていました。EMS と XMS の生い立ちの関連は不明ですが、2 つのドライバが 1 つ
の拡張メモリを操作するようになり、色々と問題が発生してきました。
　そこで、EMSメモリエミューレーション用の領域を予め確保したり、使用する領域
を（使用者が）調整して拡張メモリを多重使用しないようにするといった措置が取ら
れたようです（その時代にPCを使いこなしてないので詳細は不明）。

　EMM386.EXE はそんな中生まれてきたものです（以下に述べる実装をしてない古い
バージョンも存在します。その場合 XMS を利用していないようです。なお、EMM386
の説明は拡張メモリエミュレータとなっています）。

　拡張メモリ管理ドライバである XMS を利用しながら、EMS の機能を提供するのが
目的です。
　EMS の機能を提供するためには何らかの方法でバンクメモリの仕様を実現しなけれ
ばなりません。EMM386 はこの実現のために 80386 のページング機構 を採用しまし
た。ページングとは平たく言えば、物理的に存在するメモリ（物理メモリ）をすきな
アドレスに張りつけられる機能です。
　仮想記憶などによく利用されますが、EMSメモリのエミュレーションにもうってつ
けの機能と言えます。

　しかし、ページング機構を実現するには、いくつかの代償を支払わねばなりません
でした。
　まず、CPUの動作モードをプロテクトモードに切り換える、ということです。リアル
モードは 80386 互換なのでページングは使用できません。つまり、EMM386.EXE を組
み込んだ DOS は常にプロテクトモード（DOS自体は仮想86モード）動作しています。

　これだけではなく、仮想86モードではいくつかの命令がセキュリティ（プロテクト）
の関係から使用できなくなっています。CPU モードを切り換えたりする命令は当然
使用できません。使用しようとするとエラーが発生します。

　XMS Driver は自力で CPU モードを切り換えているハズですから、HIMEM.SYS と
EMM386 の間に特別な仕組みがない限りはエラーが発生します。エラーが発生しては、
拡張メモリが利用できませんから、EMM386.EXE はこれらの特殊な命令（特権命令と
呼ばれる）をエミュレートしているハズです。
　これは、以前 DOS が仮想86モードで動作中に CPUモード を自力で切り換えること
が出来たことなどから推論したものです。

※変な話ですが、きちんとエミュレーションされてるため

	『0F20C0  mov eax,cr0』

　を実行し、eax の bit 31 を調べて 1 ならばプロテクト(仮想86)モードです。

■VCPI / DPMI

　EMM386 が DOS を仮想86モードに切り換えたために唯一発生した障害です。
　DOS-Extender がそのままでは動作しなくなりました。動作させても、DOS に復帰
できなくなります。

　VCPI は EMS との共存を目的に設計されています。
　VCPI 自体は実にシンプルな設計です。シンプルすぎて使いにくい面もありますが。

　DPMI は VCPI よりもより高機能な DOS-Extender のためのサーバ機能です。
　Windows は DPMIベース で動作している模様です。Windows のための仕様と言って
も過言ではないと思います。Windows DOS プロンプトでは DPMI 機能が提供されてい
ます。

　余談ですが PC-98 の DPMI.EXE は、VCPI サーバのクライアントソフトとして動作
するようです。

■歴史と実装

　XMS もそうですが、管理単位が 1KB になっています。
　80286 の最大メモリである 16MB / 2^16 = 256 byte でないだけいいとは思います
が、ページングの単位である 4KB と比べると扱いにくいものになっています。
　EMS も元々バンクメモリのために作られた仕様であるため、64KB を 4 つに分けた
16KB が単位となっています。これは、ページングでエミュレートするには楽ですが、
こういうのが綺麗に揃ってればなぁーと思えなくもありません。

　XMS2.0 と XMS3.0 にしても、XMS3.0 があれば十分用が足りますが、互換性のために
XMS2.0 がメインで使われています（XMS3.0 の日本語資料がないので、日本での使用者
はかなり少ないと思われる）。

　EMS の方はまだ詳しく読んでませんが、いわずもがなでしょう。
　Version も 4.0 まであることですし……。

　つまり何が言いたいかと、こういうことを調べてると、なんでこう統一感がない仕様
かなぁーと思っても、歴史的にその時々に最善の選択であるということがよく分かると
いうことです。
　よく考えて作ってあるなと感じます。

　CPU 発展の計画性のなさが一番原因でしょうけど……（286→386の２段階の拡張が
一番ひどいですね）。もう少し先を見てほしいような気もしますね（存在もしないも
のの先を見ろってのも変な話ですが）。
　あとは、丁寧すぎるまでの互換性。商売上しようがないのでしょうけどね、そんな
ところまで……と思うことはあります。

